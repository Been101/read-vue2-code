{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["export function isFunction(fn) {\n  return typeof fn === 'function'\n}\n\nexport function isObject(val) {\n  return typeof val === 'object' && val !== null\n}\n\nexport const isArray = Array.isArray ","let oldArrayPrototype = Array.prototype // 获取数组的老的原型方法\n\nexport const arrayMethods = Object.create(oldArrayPrototype) // 让 arrayMethods 通过 __proto__ 能获取到数组的方法\n\nconst methods = ['push', 'pop', 'splice', 'shift','unshift', 'reverse', 'sort'] // 只有这七个方法可以导致数组发生变化\n\nmethods.forEach(method => {\n  arrayMethods[method] = function(...args) {\n    console.log('数组方法进行重写操作')\n\n    // 数组新增的属性 要看一下是不是对象， 如果是对象， 继续进行劫持\n    // 需要调用数组原生逻辑\n    // arr.push(1) // this 就是 arr\n    oldArrayPrototype[method].call(this, ...args)\n\n    // TODO 可以添加自己逻辑。 这种方式叫函数劫持 或 切片\n\n    let inserted = null\n    const ob = this.__ob__\n    switch (method) {\n      case 'splice':   // 修改 删除 添加  arr.splice(0, 0, 100, 200, 300)\n        inserted = args.slice(2); // splice 方法从第三个参数起是增添的新数据\n        break;\n      case 'push':\n      case 'unshift':\n        inserted = args; // 调用 push 和 unshift 传递的参数就是新增的逻辑\n        break;\n    }\n\n    // inserted 看一下它是否需要进行劫持\n    if(inserted) {\n      ob.observeArray(inserted)\n    }\n  }\n})","import { isArray, isObject } from \"../utils\";\nimport { arrayMethods } from \"./array\";\n\nclass Observer {\n  constructor(value) {\n    // 添加一个自定义属性绑定this, 方便在 array.js 中使用观察数组方法且不让 __ob__ 被遍历到， 否则就走对象劫持的逻辑了， 就会出现死循环\n    Object.defineProperty(value, '__ob__', {\n      value: this,\n      enumerable: false // 标识这个属性不能被列举出来， 不能被循环到\n    })\n\n    if(isArray(value)) {\n      // 更改数组原型方法\n      value.__proto__ = arrayMethods // 重写数组的方法\n      // 如果数组里还有数组，要继续递归重写数组的原型链\n      this.observeArray(value);\n    }else {\n      this.walk(value) // 核心就是循环对象\n\n    }\n  }\n\n  observeArray(data) { // 递归遍历数组， 对数组内部的对象再次重写 [[], []]; [{}]\n    // vm.arr[0].a = 100\n    // vm.arrp[0] = 100\n     data.forEach(item => observe(item)) // 数组里面如果式引用类型那么是响应式的\n\n  }\n\n  walk(data) {\n    Object.keys(data).forEach(key => { // 要使用 defineProperty 重新定义\n      defineReactive(data, key, data[key]);\n    })\n  }\n}\n// vue2 应用了 defineProperty 需要一加载的时候就进行递归操作，所以耗性能，如果层次过深也会浪费性能\n\n// 1. 性能优化的原则\n// a. 不要把所有数据都放在 data 中，因为所有的数据都会增加 get 和 set\n// b. 不要写数据的时候层次过深，尽量扁平化数据\n// c. 不要频繁获取数据\n// d. 如果数据不需要响应式，可以使用 Object.freeze 冻结属性\n\n// 数组也可以使用 defineProperty 但是我们很少去采用 arr[333] = 2\n// 如果数组也使用了 defineProperty 还是可以实现修改索引触发更新的，但是这种操作概率低， 所以源码中没有采用这种方式， 所有 vue 中 数组修改索引不会导致视图更新，修改 length 也不会更新\n\n// vue3中为了兼容 proxy 内部对数组用的就是 defineProperty\n// 正常用户修改数组，无非采用数组的变异方法， push, pop, splice, shift. unshift. reverse, sort\n\nfunction defineReactive(obj, key, value) { // vue2 慢的原因主要在这个方法中\n  observe(value) // 递归进行观测数据，不管有多少层，我都进行 defineProperty\n  Object.defineProperty(obj, key, {\n    get() {\n      return value; // 闭包，此 value 会向上层的 value 进行查找\n    },\n    set(newValue) { // 如果设置的是一个对象那么会再次进行劫持\n      if(newValue === value) return;\n      /**\n       *  vm.message= {a: 100} // 会更新\n       * vm.message.a = 200 // 要想这种情况也更新， 需要对新赋的值也要观察\n       * vm.message.b = 12 // vue2 无法劫持到不存在的属性，新增不存在的属性 不会更新视图\n       * vm.arr[0].name = 'ming'\n       */\n\n      console.log(`修改了${key}`);\n      observe(newValue); // \n      value = newValue\n    }\n  })\n}\n\nexport function observe(value) {\n\n  // 1. 如果 value 不是对象，那么就不用观测了， 说明写的有问题\n  if(!isObject(value)) {\n    return\n  }\n\n  if(value.__ob__) { // 一个对象不需要重复被观测\n    return;\n  }\n\n  // 需要对对象进行观测（最外层必须是一个{} 不能是数组）\n\n  // 如果一个数据已经被观测过了，就不要再进行观测了，用类来实现，我观测过就增加一个标识说明观测过了，在观测的时候可以检测是否观测过，如果观测过了就跳过检测\n\n  return new Observer(value)\n}","import { observe } from \"./observe/index\";\nimport { isFunction } from \"./utils\";\n\nexport function initState (vm) {\n  const opts = vm.$options;\n\n  if(opts.data) {\n    initData(vm)\n  }\n}\n\nfunction proxy(vm, key, source) { // 取值的时候做代理，不是暴力的把 _data 属性赋给 vm, 而且直接赋值会有命名冲突的问题\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[source][key]\n    },\n    set(newValue) {\n      vm[source][key] = newValue\n    }\n  })\n}\n\n\nfunction initData(vm) {\n  let data = vm.$options.data //\n\n  // 如果用户传递的是一个函数，则取函数的返回值作为对象，如果激素hi对象那就直接使用这个对象\n  // 只有根实例 data 可以是一个对象\n\n  // 希望 用户能够 直接 vm.message 进行取值，所以使用了一个 proxy 进行代理 vm._data\n  // data 和 vm._data 引用的是同一个  data 被劫持了  vm._data 也被劫持\n  data = vm._data =  isFunction(data) ? data.call(vm) : data\n\n  // 需要将 data 变成响应式的 Object.defineProperty\n  console.log('初始化数据')\n  observe(data)\n\n\n  data.arr.push(1)\n  for (const key in data) { // vm.message => vm._data.message\n    proxy(vm, key, '_data')  // 引用类型\n  }\n}","import { initState } from \"./state\";\n\nexport function initMixin(Vue) {\n  // 后续组件开发的时候 Vue.extend 可以创造一个子组件，子组件可以继承 Vue, 子组件也可以调用 _init 方法\n  Vue.prototype._init = function(options) {\n    const vm = this;\n\n    // 把用户的选项放到 vm 上， 这样在其他方法中都可以获取到 options 了\n    vm.$options = options; // 为了后续扩展的方法都可以获取 $options 选项\n\n    // $options 中是用户传入的数据 el, data, watch ...\n    initState(vm)\n\n    if(vm.$options.el) {\n      // 将数据挂载到页面\n      console.log('页面要挂载');\n    }\n\n  }\n}","import { initMixin } from \"./init\";\n\n// vue 要如何实现， 原型模式， 所有的功能都通过原型扩展的方式来添加\nfunction Vue(options) {\n  this._init(options) // 实现 vue 的初始化功能\n}\n\ninitMixin(Vue)\n\n// 导出 Vue 给别人用\nexport default Vue;\n\n\n/**\n * 1. new Vue 会调用 _init 方法进行初始化操作\n * 2. 会将用户的选项放到 vm.$options 上\n * 3. 会对当前属性上搜索有没有 data 数据  initState\n * 4. 有 data 判断 data 是不是一个函数， 如果是函数取返回值 initData\n * 5. observe 去观测 data 中的数据 和 vm 没关系， 说明 data 已经变成了响应式\n * 6. vm 上想取值也能取到 data 中的数据  vm._data = data 这样用户能取到 data 了， vm._data\n * 7. 用户觉得有点麻烦 vm.xxx => vm._data\n * 8.如果更新对象不存在的属性， 会导致视图不更新，如果是数组更新索引和长度不会触发更新\n * 9.如果是替换成一个新对象，新对象会被劫持， 如果是数组存放新内容 push unshift splice 新增的内容也会被劫持， 通过 __ob__ 进行标识这个对象被监控过 (在 vue中被监控的对象身上都有一个 __ob__ 这个属性)\n */"],"names":["isFunction","fn","isObject","val","isArray","Array","oldArrayPrototype","prototype","arrayMethods","Object","create","methods","forEach","method","args","console","log","call","inserted","ob","__ob__","slice","observeArray","Observer","constructor","value","defineProperty","enumerable","__proto__","walk","data","item","observe","keys","key","defineReactive","obj","get","set","newValue","initState","vm","opts","$options","initData","proxy","source","_data","arr","push","initMixin","Vue","_init","options","el"],"mappings":"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"}